<!DOCTYPE html>
<html>
  <head>
    <title>
      Option types and Ruby |
      Jimmy Cuadra
    </title>
    <link href="/stylesheets/application-58ac5912.css" rel="stylesheet" type="text/css" />
    <link href='http://feeds.feedburner.com/jimmycuadra' rel='alternate' title='RSS' type='application/rss+xml'>
    <script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create', 'UA-5500916-1');ga('send', 'pageview');</script>
  </head>
  <body>
    <header class='site-header'>
      <div class='bucket'>
        <a class='title-link' href='/' title='Jimmy Cuadra'>
          <img width="75" height="75" alt="Jimmy Cuadra" class="logo" src="/images/logo-3e3e6b15.png" />
          <hgroup>
            <h1 class='main-title'>I'm Jimmy Cuadra.</h1>
            <p>I write about programming and open source software.</p>
          </hgroup>
          <div class='clear'></div>
        </a>
      </div>
    </header>
    <nav>
      <div class='bucket'>
        <ul>
          <li><a title="Writing" href="/">Writing</a></li>
          <li><a class="sub-nav" title="Writing by tags" href="/tags/">by tags</a></li>
          <li><a title="Jimmy Cuadra's Résumé" href="/resume/">Résumé</a></li>
        </ul>
      </div>
    </nav>
    <div class='content'>
      <div class='bucket'>
        <article itemscope itemtype='http://schema.org/BlogPosting'>
          <meta content='Jimmy Cuadra' itemprop='author'>
          <header>
            <h1 class='post-title' itemprop='headline'><a title="Option types and Ruby" href="/posts/option-types-and-ruby/">Option types and Ruby</a></h1>
            <data itemprop='datePublished' value='2015-03-11'>March 11, 2015</data>
          </header>
          <div class='social'>
            <div class='g-plus' data-action='share' data-annotation='bubble' data-href='/posts/option-types-and-ruby/'></div>
            <a class='twitter-share-button' data-count='horizontal' data-text='Option types and Ruby' data-url='/posts/option-types-and-ruby/' data-via='jimmycuadra' href='https://twitter.com/share'>Tweet</a>
          </div>
          <p>I've been learning the <a href="http://www.rust-lang.org/">Rust</a> programming language over the last several months. One of the great things about learning a new programming language is that it expands your understanding of programming in general by exposing you to new ideas. Sometimes new ideas can result in lightbulb moments for programming in languages you already know. One of the things learning Rust has made me realize is how much I wish Ruby had sum types.</p>
          
          <p>A sum type is a type that has a number of "variants." These variants are alternate constructors for the type that can be differentiated from each other to confer different meaning, while still being the enclosing type. In Rust, sum types are provided through <code>enum</code>. An enum type can be destructured into a value using pattern matching via Rust's <code>match</code> operator.</p>
          
          <pre><code class="language-rust">enum Fruit {&#x000A;  Apple,&#x000A;  Banana,&#x000A;  Cherry,&#x000A;}&#x000A;&#x000A;fn print_fruit_name(fruit: Fruit) {&#x000A;  match fruit {&#x000A;    Apple =&gt; println!("Found an apple!"),&#x000A;    Banana =&gt; println!("Found a banana!"),&#x000A;    Cherry =&gt; println!("Found a cherry!"),&#x000A;  }&#x000A;}&#x000A;</code></pre>
          
          <p>We define an enum, <code>Fruit</code>, with three variants. The <code>print_fruit_name</code> function takes a <code>Fruit</code> value and then matches on it, printing a different message depending on which variant this particular <code>Fruit</code> is. For our purposes here, the reason we use <code>match</code> instead of a chain of if/else conditions is that <code>match</code> guarantees that all variants must be accounted for. If one of the three arms of the match were omitted, the program would not compile, citing a non-exhaustive pattern match.</p>
          
          <p>Enum variants can also take arguments which allow them to wrap other types of values. The most common, and probably most useful example of this is the <code>Option</code> type. This type allows you to represent the idea of a method that sometimes returns a meaningful value, and sometimes returns nothing. The same concept goes by different names sometimes. In Haskell, it's called the Maybe monad.</p>
          
          <pre><code class="language-rust">pub enum Option&lt;T&gt; {&#x000A;  Some(T),&#x000A;  None,&#x000A;}&#x000A;</code></pre>
          
          <p>An option can have two possible values: "Some" arbitrary value of any type T, or None, representing nothing. An optional value could then be returned from a method like so:</p>
          
          <pre><code class="language-rust">fn find(id: u8) -&gt; Option&lt;User&gt; {&#x000A;  if user_record_for_id_exists(id) {&#x000A;    Some(load_user(id))&#x000A;  } else {&#x000A;    None&#x000A;  }&#x000A;}&#x000A;</code></pre>
          
          <p>Code calling this method would then have to explicitly account for both possible outcomes:</p>
          
          <pre><code class="language-rust">match find(1) {&#x000A;  Some(user) =&gt; user.some_action(),&#x000A;  None =&gt; return,&#x000A;}&#x000A;</code></pre>
          
          <p>What you do in the two cases is, of course, up to you and dependent on the situation. The point is that the caller must handle each case explicitly.</p>
          
          <p>How does this relate to Ruby? Well, how often have you seen this exception when working on a Ruby program?</p>
          
          <pre><code class="language-text">NoMethodError: undefined method `foo' for nil:NilClass&#x000A;</code></pre>
          
          <p>Chances are, you've seen this a million times, and it's one of the most annoying errors. Part of why it's so bad is that associated stack traces may not make it clear where the <code>nil</code> was originally emitted. Ruby code tends to use <code>nil</code> quite liberally. Rails frequently follows the convention of methods returning <code>nil</code> to indicate either the lack of a value or the failure of some operation. Because there are loose <code>nil</code>s everywhere, they end up in your code in places you don't expect and tripping you up.</p>
          
          <p>This problem is not unique to Ruby. It's been seen in countless other languages. Java programmers rue the NullPointerException, and <a href="https://en.wikipedia.org/wiki/Tony_Hoare">Tony Hoare</a> refers to the issue as his billion dollar mistake.</p>
          
          <p>What, then, might we learn from the concept of an option type in regards to Ruby? We could certainly simulate an Option type by creating our own class that wraps another value, but that doesn't really solve anything since it can't force callers to explicitly unwrap it. You'd simply end up with:</p>
          
          <pre><code class="language-text">NoMethodError: undefined method `foo' for #&lt;Option:0x007fddcc4c1ab0&gt;&#x000A;</code></pre>
          
          <p>But we do have a mechanism in Ruby that will stop a caller cold in its tracks if it doesn't handle a particular case: exceptions. While it's a common adage not to "use exceptions for control flow," let's take a look at how exceptions might be used to bring some of the benefits of avoiding <code>nil</code> through sum types. Imagine this example using an Active-Record-like <code>User</code> object:</p>
          
          <pre><code class="language-ruby">def message_user(email, message_content)&#x000A;  user = User.find_by_email(email)&#x000A;  message = Message.new(message_content)&#x000A;  message.send_to(user)&#x000A;end&#x000A;</code></pre>
          
          <p>The <code>find_by_email</code> method will try looking up a user from the database by their email address, and return either a user object or <code>nil</code>. It's easy to forget this, and move along assuming our <code>user</code> variable is bound to a user object. In the case where no user is found by the provided email address, we end up passing <code>nil</code> to <code>Message#send_to</code>, which will crash our program, because it always expects a user.</p>
          
          <p>One way to get around this is to just use a condition to check if <code>user</code> is <code>nil</code> or not before proceeding. But again, this is easy to forget. If we control the implementation of the <code>User</code> class, we can force callers to explicitly handle this case by raising an exception when no user is found instead of simply returning <code>nil</code>.</p>
          
          <pre><code class="language-ruby">def message_user(email, message_content)&#x000A;  user = User.find_by_email(email)&#x000A;  message = Message.new(message_content)&#x000A;  message.send_to(user)&#x000A;rescue UserNotFound&#x000A;  logger.warn("Failed to send message to unknown user with email #{email}.")&#x000A;end&#x000A;</code></pre>
          
          <p>Now <code>message_user</code> explicitly handles the "none" case, and if it doesn't, an exception will be raised right where the <code>nil</code> would otherwise have been introduced. Of course, the program will still run if this exception isn't handled, but it will crash in the case where it does, and the crash will have a more useful exception than the dreaded <code>NoMethodError</code> on <code>nil</code>. Forcing the caller to truly account for all cases is something that pattern matching provides in Rust which is not possible in Ruby, but using exceptions to provide earlier failures and better error messages gets us a bit closer to the practical benefit.</p>
          
          <p>There are other approaches to dealing with the propagation of <code>nil</code> values in Ruby. Another well known approach is to use the null object pattern, returning a "dummy" object (in our example, a <code>User</code>), that responds to all the same messages as a real user but simply has no effect. Some people would argue that is a more object-oriented or Rubyish approach, but I find that it introduces more complexity than its benefit is worth.</p>
          
          <p>Using exceptions as part of the interfaces of your objects forces callers to handle those behaviors, and causes early errors when they don't, allowing them to get quick, accurate feedback when something goes wrong.</p>
          <footer>
            <p>
              This post was tagged with <a title="Writing tagged with ruby" itemprop="keywords" href="/posts/tags/ruby/">ruby</a> and <a title="Writing tagged with rust" itemprop="keywords" href="/posts/tags/rust/">rust</a>.
            </p>
            <p>
              Find more content by <a title="Browse writing by tags" href="/tags/">browsing by tags</a>.
            </p>
          </footer>
        </article>
      </div>
    </div>
    <footer class='site-footer'>
      <div class='bucket'>
        <p>Logo by <a href="http://stephanielucido.com/" title="Stephanie Lucido">Stephanie Lucido</a>.</p>
        <small>
          &copy; 2015 Jimmy Cuadra. All rights reserved.
        </small>
      </div>
    </footer>
    <script src="/javascripts/application-f844c8db.js" type="text/javascript"></script>
    <script>
    (function() {
      var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
      po.src = 'https://apis.google.com/js/platform.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
    })();
    (function(d, t) {
      var e = d.createElement(t), s = d.getElementsByTagName(t)[0];
      e.type = 'text/javascript'; e.async = true; e.src = '//platform.twitter.com/widgets.js';
      s.parentNode.insertBefore(e, s);
    })(document, 'script');
    </script>
  </body>
</html>
