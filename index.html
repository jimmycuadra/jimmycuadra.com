<!DOCTYPE html>
<html>
  <head>
    <title>
      
      Jimmy Cuadra
    </title>
    <link href="/stylesheets/application-58ac5912.css" rel="stylesheet" />
    <link href='http://feeds.feedburner.com/jimmycuadra' rel='alternate' title='RSS' type='application/rss+xml'>
    <script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create', 'UA-5500916-1');ga('send', 'pageview');</script>
  </head>
  <body>
    <header class='site-header'>
      <div class='bucket'>
        <a class='title-link' href='/' title='Jimmy Cuadra'>
          <img width="75" height="75" alt="Jimmy Cuadra" class="logo" src="/images/logo-3e3e6b15.png" />
          <hgroup>
            <h1 class='main-title'>I'm Jimmy Cuadra.</h1>
            <p>I write about programming and open source software.</p>
          </hgroup>
          <div class='clear'></div>
        </a>
      </div>
    </header>
    <nav>
      <div class='bucket'>
        <ul>
          <li><a title="Writing" href="/">Writing</a></li>
          <li><a class="sub-nav" title="Writing by tags" href="/tags/">by tags</a></li>
          <li><a title="Jimmy Cuadra's Résumé" href="/resume/">Résumé</a></li>
        </ul>
      </div>
    </nav>
    <div class='content'>
      <div class='bucket'>
        <article itemscope itemtype='http://schema.org/BlogPosting'>
          <meta content='Jimmy Cuadra' itemprop='author'>
          <header>
            <h1 class='post-title' itemprop='headline'><a title="Option types and Ruby" href="/posts/option-types-and-ruby/">Option types and Ruby</a></h1>
            <data itemprop='datePublished' value='2015-03-11'>March 11, 2015</data>
          </header>
          <div class='social'>
            <div class='g-plus' data-action='share' data-annotation='bubble' data-href='/posts/option-types-and-ruby/'></div>
            <a class='twitter-share-button' data-count='horizontal' data-text='Option types and Ruby' data-url='/posts/option-types-and-ruby/' data-via='jimmycuadra' href='https://twitter.com/share'>Tweet</a>
          </div>
          <p>I've been learning the <a href="http://www.rust-lang.org/">Rust</a> programming language over the last several months. One of the great things about learning a new programming language is that it expands your understanding of programming in general by exposing you to new ideas. Sometimes new ideas can result in lightbulb moments for programming in languages you already know. One of the things learning Rust has made me realize is how much I wish Ruby had sum types.</p>
          
          <p>A sum type is a type that has a number of "variants." These variants are alternate constructors for the type that can be differentiated from each other to confer different meaning, while still being the enclosing type. In Rust, sum types are provided through <code>enum</code>. An enum type can be destructured into a value using pattern matching via Rust's <code>match</code> operator.</p>
          
          <pre><code class="language-rust">enum Fruit {&#x000A;  Apple,&#x000A;  Banana,&#x000A;  Cherry,&#x000A;}&#x000A;&#x000A;fn print_fruit_name(fruit: Fruit) {&#x000A;  match fruit {&#x000A;    Apple =&gt; println!("Found an apple!"),&#x000A;    Banana =&gt; println!("Found a banana!"),&#x000A;    Cherry =&gt; println!("Found a cherry!"),&#x000A;  }&#x000A;}&#x000A;</code></pre>
          
          <p>We define an enum, <code>Fruit</code>, with three variants. The <code>print_fruit_name</code> function takes a <code>Fruit</code> value and then matches on it, printing a different message depending on which variant this particular <code>Fruit</code> is. For our purposes here, the reason we use <code>match</code> instead of a chain of if/else conditions is that <code>match</code> guarantees that all variants must be accounted for. If one of the three arms of the match were omitted, the program would not compile, citing a non-exhaustive pattern match.</p>
          
          <p>Enum variants can also take arguments which allow them to wrap other types of values. The most common, and probably most useful example of this is the <code>Option</code> type. This type allows you to represent the idea of a method that sometimes returns a meaningful value, and sometimes returns nothing. The same concept goes by different names sometimes. In Haskell, it's called the Maybe monad.</p>
          
          <pre><code class="language-rust">pub enum Option&lt;T&gt; {&#x000A;  Some(T),&#x000A;  None,&#x000A;}&#x000A;</code></pre>
          
          <p>An option can have two possible values: "Some" arbitrary value of any type T, or None, representing nothing. An optional value could then be returned from a method like so:</p>
          
          <pre><code class="language-rust">fn find(id: u8) -&gt; Option&lt;User&gt; {&#x000A;  if user_record_for_id_exists(id) {&#x000A;    Some(load_user(id))&#x000A;  } else {&#x000A;    None&#x000A;  }&#x000A;}&#x000A;</code></pre>
          
          <p>Code calling this method would then have to explicitly account for both possible outcomes:</p>
          
          <pre><code class="language-rust">match find(1) {&#x000A;  Some(user) =&gt; user.some_action(),&#x000A;  None =&gt; return,&#x000A;}&#x000A;</code></pre>
          
          <p>What you do in the two cases is, of course, up to you and dependent on the situation. The point is that the caller must handle each case explicitly.</p>
          
          <p>How does this relate to Ruby? Well, how often have you seen this exception when working on a Ruby program?</p>
          
          <pre><code class="language-text">NoMethodError: undefined method `foo' for nil:NilClass&#x000A;</code></pre>
          
          <p>Chances are, you've seen this a million times, and it's one of the most annoying errors. Part of why it's so bad is that associated stack traces may not make it clear where the <code>nil</code> was originally emitted. Ruby code tends to use <code>nil</code> quite liberally. Rails frequently follows the convention of methods returning <code>nil</code> to indicate either the lack of a value or the failure of some operation. Because there are loose <code>nil</code>s everywhere, they end up in your code in places you don't expect and tripping you up.</p>
          
          <p>This problem is not unique to Ruby. It's been seen in countless other languages. Java programmers rue the NullPointerException, and <a href="https://en.wikipedia.org/wiki/Tony_Hoare">Tony Hoare</a> refers to the issue as his billion dollar mistake.</p>
          
          <p>What, then, might we learn from the concept of an option type in regards to Ruby? We could certainly simulate an Option type by creating our own class that wraps another value, but that doesn't really solve anything since it can't force callers to explicitly unwrap it. You'd simply end up with:</p>
          
          <pre><code class="language-text">NoMethodError: undefined method `foo' for #&lt;Option:0x007fddcc4c1ab0&gt;&#x000A;</code></pre>
          
          <p>But we do have a mechanism in Ruby that will stop a caller cold in its tracks if it doesn't handle a particular case: exceptions. While it's a common adage not to "use exceptions for control flow," let's take a look at how exceptions might be used to bring some of the benefits of avoiding <code>nil</code> through sum types. Imagine this example using an Active-Record-like <code>User</code> object:</p>
          
          <pre><code class="language-ruby">def message_user(email, message_content)&#x000A;  user = User.find_by_email(email)&#x000A;  message = Message.new(message_content)&#x000A;  message.send_to(user)&#x000A;end&#x000A;</code></pre>
          
          <p>The <code>find_by_email</code> method will try looking up a user from the database by their email address, and return either a user object or <code>nil</code>. It's easy to forget this, and move along assuming our <code>user</code> variable is bound to a user object. In the case where no user is found by the provided email address, we end up passing <code>nil</code> to <code>Message#send_to</code>, which will crash our program, because it always expects a user.</p>
          
          <p>One way to get around this is to just use a condition to check if <code>user</code> is <code>nil</code> or not before proceeding. But again, this is easy to forget. If we control the implementation of the <code>User</code> class, we can force callers to explicitly handle this case by raising an exception when no user is found instead of simply returning <code>nil</code>.</p>
          
          <pre><code class="language-ruby">def message_user(email, message_content)&#x000A;  user = User.find_by_email(email)&#x000A;  message = Message.new(message_content)&#x000A;  message.send_to(user)&#x000A;rescue UserNotFound&#x000A;  logger.warn("Failed to send message to unknown user with email #{email}.")&#x000A;end&#x000A;</code></pre>
          
          <p>Now <code>message_user</code> explicitly handles the "none" case, and if it doesn't, an exception will be raised right where the <code>nil</code> would otherwise have been introduced. Of course, the program will still run if this exception isn't handled, but it will crash in the case where it does, and the crash will have a more useful exception than the dreaded <code>NoMethodError</code> on <code>nil</code>. Forcing the caller to truly account for all cases is something that pattern matching provides in Rust which is not possible in Ruby, but using exceptions to provide earlier failures and better error messages gets us a bit closer to the practical benefit.</p>
          
          <p>There are other approaches to dealing with the propagation of <code>nil</code> values in Ruby. Another well known approach is to use the null object pattern, returning a "dummy" object (in our example, a <code>User</code>), that responds to all the same messages as a real user but simply has no effect. Some people would argue that is a more object-oriented or Rubyish approach, but I find that it introduces more complexity than its benefit is worth.</p>
          
          <p>Using exceptions as part of the interfaces of your objects forces callers to handle those behaviors, and causes early errors when they don't, allowing them to get quick, accurate feedback when something goes wrong.</p>
          <footer>
            <p>
              This post was tagged with <a title="Writing tagged with ruby" itemprop="keywords" href="/posts/tags/ruby/">ruby</a> and <a title="Writing tagged with rust" itemprop="keywords" href="/posts/tags/rust/">rust</a>.
            </p>
            <p>
              Find more content by <a title="Browse writing by tags" href="/tags/">browsing by tags</a>.
            </p>
          </footer>
        </article>
        <article itemscope itemtype='http://schema.org/BlogPosting'>
          <meta content='Jimmy Cuadra' itemprop='author'>
          <header>
            <h1 class='post-title' itemprop='headline'><a title="etcd 2.0 static bootstrapping on CoreOS and Vagrant" href="/posts/etcd-2-0-static-bootstrapping-on-coreos-and-vagrant/">etcd 2.0 static bootstrapping on CoreOS and Vagrant</a></h1>
            <data itemprop='datePublished' value='2015-02-05'>February 05, 2015</data>
          </header>
          <div class='social'>
            <div class='g-plus' data-action='share' data-annotation='bubble' data-href='/posts/etcd-2-0-static-bootstrapping-on-coreos-and-vagrant/'></div>
            <a class='twitter-share-button' data-count='horizontal' data-text='etcd 2.0 static bootstrapping on CoreOS and Vagrant' data-url='/posts/etcd-2-0-static-bootstrapping-on-coreos-and-vagrant/' data-via='jimmycuadra' href='https://twitter.com/share'>Tweet</a>
          </div>
          <h2 id="the-problem">The problem</h2>
          
          <p><a href="https://coreos.com/">CoreOS</a> provides a pretty good setup for running a cluster of machines with <a href="https://www.vagrantup.com/">Vagrant</a>. You can find this setup at <a href="https://github.com/coreos/coreos-vagrant">coreos/coreos-vagrant</a>. Something I've found annoying, however, is that whenever you start a new cluster, you need to get a new discovery token from CoreOS's <a href="https://coreos.com/docs/cluster-management/setup/cluster-discovery/">hosted discovery service</a>. This is necessary for the <a href="https://github.com/coreos/etcd">etcd</a> instances running on each machine to find each other and form a quorum. The discovery token is written to the machines on initial boot via the cloud-config file named <code>user-data</code>. If you destroy the machines and recreate them, you need to use a fresh discovery token. This didn't sit right with me, as I want to check everything into version control, and didn't want to have a lot of useless commits changing the discovery token every time I recreated the cluster.</p>
          
          <h2 id="the-solution">The solution</h2>
          
          <p>Fortunately, etcd doesn't rely on the hosted discovery service. You can also bootstrap etcd statically if you know the IPs and ports everything will be running on in advance. It turns out that CoreOS's Vagrantfile is already configured to provide a static IP to each machine, so these IPs can simply be hardcoded into the cloud-config. There's one more snag, which is that etcd 0.4.6 (the one that currently ships in CoreOS) gets confused if the list of IPs you include when bootstrapping includes the current machine. That would mean that the cloud-config for each machine would have to be slightly different because it'd have to include the whole list, minus itself. Without introducing an additional layer of abstraction of your own, there isn't an easy way to provide a dynamic cloud-config file that would do this. Fortunately, the <a href="https://coreos.com/blog/etcd-2.0-release-first-major-stable-release/">newly released etcd 2.0.0</a> improves on the static bootstrapping story by allowing you to provide the full list of IPs on every machine. Because etcd 2.0 doesn't ship with CoreOS yet, we'll run it in a container.</p>
          
          <p>For this example, we'll use a cluster of three machines, just to keep the cloud-config a bit shorter. Five machines is the recommended size for most uses. Assuming you already have Vagrant and VirtualBox installed, clone the <a href="https://github.com/coreos/coreos-vagrant">coreos/coreos-vagrant</a> repository and copy <code>config.rb.sample</code> to <code>config.rb</code>. Open <code>config.rb</code> and uncomment <code>$num_instances</code>, setting its value to <code>3</code>.</p>
          
          <pre><code class="language-ruby"># Size of the CoreOS cluster created by Vagrant&#x000A;$num_instances = 3&#x000A;</code></pre>
          
          <p>Next, create a new file called <code>user-data</code> with the following contents:</p>
          
          <pre><code class="language-yaml">#cloud-config&#x000A;&#x000A;coreos:&#x000A;  fleet:&#x000A;    etcd-servers: http://$private_ipv4:2379&#x000A;    public-ip: $private_ipv4&#x000A;  units:&#x000A;    - name: etcd.service&#x000A;      command: start&#x000A;      content: |&#x000A;        Description=etcd 2.0&#x000A;        After=docker.service&#x000A;&#x000A;        [Service]&#x000A;        EnvironmentFile=/etc/environment&#x000A;        TimeoutStartSec=0&#x000A;        SyslogIdentifier=writer_process&#x000A;        ExecStartPre=-/usr/bin/docker kill etcd&#x000A;        ExecStartPre=-/usr/bin/docker rm etcd&#x000A;        ExecStartPre=/usr/bin/docker pull quay.io/coreos/etcd:v2.0.0&#x000A;        ExecStart=/bin/bash -c "/usr/bin/docker run \&#x000A;          -p 2379:2379 \&#x000A;          -p 2380:2380 \&#x000A;          --name etcd \&#x000A;          -v /opt/etcd:/opt/etcd \&#x000A;          -v /usr/share/ca-certificates/:/etc/ssl/certs \&#x000A;          quay.io/coreos/etcd:v2.0.0 \&#x000A;          -data-dir /opt/etcd \&#x000A;          -name %H \&#x000A;          -listen-client-urls http://0.0.0.0:2379 \&#x000A;          -advertise-client-urls http://$COREOS_PRIVATE_IPV4:2379 \&#x000A;          -listen-peer-urls http://0.0.0.0:2380 \&#x000A;          -initial-advertise-peer-urls http://$COREOS_PRIVATE_IPV4:2380 \&#x000A;          -initial-cluster core-01=http://172.17.8.101:2380,core-02=http://172.17.8.102:2380,core-03=http://172.17.8.103:2380\&#x000A;          -initial-cluster-state new"&#x000A;        ExecStop=/usr/bin/docker kill etcd&#x000A;&#x000A;        [X-Fleet]&#x000A;        Conflicts=etcd*&#x000A;    - name: fleet.service&#x000A;      command: start&#x000A;</code></pre>
          
          <p>Now just run <code>vagrant up</code> and in a few minutes you'll have a cluster of three CoreOS machines running etcd 2.0 with no discovery token needed!</p>
          
          <p>If you want to run <code>fleetctl</code> inside one of the CoreOS VMs, you'll need to set the default etcd endpoint, because the current fleet still expects etcd to be on port 4001:</p>
          
          <pre><code class="language-bash">export FLEETCTL_ENDPOINT=http://127.0.0.1:2379&#x000A;</code></pre>
          
          <p>If you don't care about how that all works and just want a working cluster, you can stop here. If you want to understand the guts of that cloud-config more, keep reading.</p>
          
          <h2 id="the-details">The details</h2>
          
          <p>One of the changes in CoreOS 2.0 is that it now uses port 2379 and 2380 (as opposed to etcd 0.4.6 which used 4001 and 7001.) The <code>fleet</code> section of the cloud-config tells fleet how to connect to etcd. This is necessary because the version of fleet that ships with CoreOS now still defaults to port 4001. Once etcd 2.0 is shipping in CoreOS, I'm sure fleet will be updated to match.</p>
          
          <p>The <code>units</code> section of the cloud-config creates systemd units that will be placed in <code>/etc/systemd/system/</code> on each machine. CoreOS ships with a default unit file for etcd, but we overwrite it here (simply by using the same service name, etcd.service) to use etcd 2.0 with our own configuration.</p>
          
          <p>The bulk of the cloud-config is the etcd.service unit file. Most of it is the same as a standard CoreOS unit file for a Docker container. The interesting bits are the arguments to the etcd process that runs in the container:</p>
          
          <ul>
            <li><code>-listen-client-urls</code>: This is the interface and port that the current machine's etcd should bind to for the client API, e.g. etcdctl. It's set to 0.0.0.0 to bind it to all interfaces, and it uses port 2379 which is the standard port, beginning in etcd 2.0.</li>
            <li><code>-advertise-client-urls</code>: This is the list of URLs etcd will announce as available for clients to contact.</li>
            <li><code>-listen-peer-urls</code>: Similar to the client URL version, this defines how the peer service should bind to the network. Again, we bind it to all interfaces and use the standard peer port of 2380.</li>
            <li><code>-initial-advertise-peer-urls</code>: Similar to the client version, this defines how etcd will announce its peer service to other etcd processes on other machines.</li>
            <li><code>-initial-cluster</code>: This is the secret sauce that keeps us from having to use a discovery token. We provide a list of each etcd service running in our cluster, mapping each machine's hostname to its etcd peer URL. Because we know which IP addresses Vagrant is going to use, we can simply enumerate them here. If you were running a cluster of a different size, this is where you would add or remove machines from the list.</li>
            <li><code>-initial-cluster-state</code>: A value of <code>new</code> here tells etcd that it's joining a brand new cluster. If you were to later add another machine to the existing cluster, you'd change the value here in that machine's cloud-config.</li>
          </ul>
          
          <p>It's worth noting that the arguments that begin with "initial" are just that: data that etcd needs in order to boot the first time. Once the cluster has booted once and formed a quorum, these arguments will be ignored on subsequent boots, because everything etcd needs to know will have been stored in its data directory (<code>/opt/etcd</code>) in this case.</p>
          
          <p>This is all pretty complicated, but it will get easier once etcd 2.0 and a compatible fleet are shipped with CoreOS itself. Then the built-in etcd.service unit can be used again, and all the configuration options can be written in YAML format just like the <code>fleet</code> section in this particular cloud-config.</p>
          <footer>
            <p>
              This post was tagged with <a title="Writing tagged with coreos" itemprop="keywords" href="/posts/tags/coreos/">coreos</a>, <a title="Writing tagged with devops" itemprop="keywords" href="/posts/tags/devops/">devops</a>, <a title="Writing tagged with etcd" itemprop="keywords" href="/posts/tags/etcd/">etcd</a>, and <a title="Writing tagged with vagrant" itemprop="keywords" href="/posts/tags/vagrant/">vagrant</a>.
            </p>
            <p>
              Find more content by <a title="Browse writing by tags" href="/tags/">browsing by tags</a>.
            </p>
          </footer>
        </article>
        <article itemscope itemtype='http://schema.org/BlogPosting'>
          <meta content='Jimmy Cuadra' itemprop='author'>
          <header>
            <h1 class='post-title' itemprop='headline'><a title="Securing CoreOS with iptables" href="/posts/securing-coreos-with-iptables/">Securing CoreOS with iptables</a></h1>
            <data itemprop='datePublished' value='2015-01-30'>January 30, 2015</data>
          </header>
          <div class='social'>
            <div class='g-plus' data-action='share' data-annotation='bubble' data-href='/posts/securing-coreos-with-iptables/'></div>
            <a class='twitter-share-button' data-count='horizontal' data-text='Securing CoreOS with iptables' data-url='/posts/securing-coreos-with-iptables/' data-via='jimmycuadra' href='https://twitter.com/share'>Tweet</a>
          </div>
          <p>I've been keeping a close eye on <a href="https://coreos.com/">CoreOS</a> since it was originally announced, and in the last few months I've actually started using it for a few things. As a young project, CoreOS has lots of rough edges in terms of documentation and usability. One of the issues I ran into was how to secure a CoreOS machine's public network. By default, a fresh CoreOS installation has no firewall rules, allowing all inbound network traffic.</p>
          
          <p>In order to secure a CoreOS machine, I had to learn how to configure the firewall. I use the common <a href="http://www.netfilter.org/projects/iptables/">iptables</a> utility for this purpose. While I was vaguely familiar with iptables, I'd never really had to learn it, so I delved in to get a more thorough understanding of it. There are plenty of resources to learn iptables on the web, so I won't go into that too much here. The issue specific to CoreOS is how to configure iptables when launching a new machine.</p>
          
          <p>CoreOS is unusual in that it is extremely minimal. It's designed for all programs to be run inside Linux containers, so the OS itself contains only the subsystems and tools necessary to achieve that.  iptables, however, is one of the programs that does run on the OS itself.</p>
          
          <p>With a more traditional Linux distribution, it's common to launch a new instance and then provision it with a tool like Chef or Puppet. Your configuration lives in a Git repository somewhere and you run a program on the target machine after it's booted to converge it into the desired state. CoreOS is missing a lot of the infrastructure assumed to be present by tools like Chef and Puppet, so they are not supported. It is possible to run Ansible, a push-based configuration management tool, on a CoreOS host, but I'm not a fan of Ansible for reasons that are beyond the scope of this post, and plus, using a complex configuration management tool is sort of against the spirit of CoreOS, where almost everything should happen in containers.</p>
          
          <p>For very minimal on-boot configuration, CoreOS supports a subset of cloud-config, the YAML-based configuration format from the <a href="http://cloudinit.readthedocs.org/en/latest/index.html">cloud-init</a> tool. CoreOS instances can be provided a cloud-config file and will perform certain actions on boot. cloud-config can be used to load iptables with a list of rules for a more secure network.</p>
          
          <p>I'll provide the relevant portion of the cloud-config I use on <a href="https://www.digitalocean.com/">DigitalOcean</a>, then explain the relevant pieces:</p>
          
          <pre><code class="language-yaml">#cloud-config&#x000A;&#x000A;coreos:&#x000A;  units:&#x000A;    - name: iptables-restore.service&#x000A;      enable: true&#x000A;write_files:&#x000A;  - path: /var/lib/iptables/rules-save&#x000A;    permissions: 0644&#x000A;    owner: root:root&#x000A;    content: |&#x000A;      *filter&#x000A;      :INPUT DROP [0:0]&#x000A;      :FORWARD DROP [0:0]&#x000A;      :OUTPUT ACCEPT [0:0]&#x000A;      -A INPUT -i lo -j ACCEPT&#x000A;      -A INPUT -i eth1 -j ACCEPT&#x000A;      -A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT&#x000A;      -A INPUT -p tcp -m tcp --dport 22 -j ACCEPT&#x000A;      -A INPUT -p tcp -m tcp --dport 80 -j ACCEPT&#x000A;      -A INPUT -p tcp -m tcp --dport 443 -j ACCEPT&#x000A;      -A INPUT -p icmp -m icmp --icmp-type 0 -j ACCEPT&#x000A;      -A INPUT -p icmp -m icmp --icmp-type 3 -j ACCEPT&#x000A;      -A INPUT -p icmp -m icmp --icmp-type 11 -j ACCEPT&#x000A;      COMMIT&#x000A;</code></pre>
          
          <p>Every cloud-config file must start with <code>#cloud-config</code> exactly. I learned the hard way that this is not just a comment – it actually tells CoreOS to treat the file as a cloud-config. Otherwise it will assume it's a shell script and just run it as such.</p>
          
          <p>The following lines are <a href="http://www.yaml.org/">YAML</a> syntax. The <code>coreos</code> section is a CoreOS-specific extension to cloud-init's cloud-config format. The <code>units</code> section within it will automatically perform the specified action(s) on the specified <a href="http://www.freedesktop.org/wiki/Software/systemd/">systemd</a> units. systemd is the init system used by CoreOS, and many of the OS's core operations are tied closely to it. "Units" are essentially processes that are managed by systemd and represented on disk by unit files that define how the unit should behave.</p>
          
          <p>The systemd unit <code>iptables-restore.service</code> ships with CoreOS but is not enabled by default. <code>enable: true</code> turns it on and will cause it to run on boot after every reboot. Here are the important contents of that unit file:</p>
          
          <pre><code class="language-ini">[Service]&#x000A;Type=oneshot&#x000A;ExecStart=/sbin/iptables-restore /var/lib/iptables/rules-save&#x000A;</code></pre>
          
          <p>The unit file defines a "oneshot" job, meaning it simply executes and exits and is not intended to stay running permanently. The command run is the <code>iptables-restore</code> utility, which accepts an iptables script file defining rules to be loaded into iptables. Whenever the system reboots, all iptables rules are flushed and must be reloaded from this script. That's exactly what <code>iptables-restore</code> does. The script it loads is expected to live at <code>/var/lib/iptables/rules-save</code>, which brings us to the second section of the cloud-config file.</p>
          
          <p>cloud-config's <code>write_files</code> section will, unsurprisingly, write files with the given content to the file system. The content field is the most important part here. This defines the iptables rules to load. The details of this configuration can be fully explained by reading the iptables documentation, but to summarize, these rules:</p>
          
          <ul>
            <li>Allow all input to localhost</li>
            <li>Allow all input on the private network interface</li>
            <li>Allow all connections that are currently established, which prevents existing SSH sessions from being suddenly terminated</li>
            <li>Allow incoming TCP traffic on ports 22 (SSH), 80 (HTTP), and 443 (HTTPS)</li>
            <li>Allow incoming ICMP traffic for echo replies, unreachable destination messages, and time exceeded messages</li>
            <li>Drop all other incoming traffic</li>
            <li>Drop all traffic attempting to forward through the network</li>
            <li>Allow all outbound traffic</li>
          </ul>
          
          <p>The three TCP ports allowed are pretty standard, but those are the rules you'd be most likely to change or augment depending on what services you'll be running on your CoreOS machine.</p>
          
          <p>After CoreOS boots, SSH into it, and verify that iptables was configured properly by running <code>sudo iptables -S</code> (to see it listed in the same format as above) or with <code>sudo iptables -nvL</code> (for the more standard list format).</p>
          
          <p>That's pretty much it! As you can see, there are a lot of related technologies to learn when venturing into CoreOS. Several of these were new for me, so there was a lot of learning involved in getting this working. For reference, the entire cloud-config I use for CoreOS on DigitalOcean can be found in <a href="https://gist.github.com/jimmycuadra/fe79ae8857f3f0d0cae1">this Gist</a>.</p>
          <footer>
            <p>
              This post was tagged with <a title="Writing tagged with coreos" itemprop="keywords" href="/posts/tags/coreos/">coreos</a> and <a title="Writing tagged with devops" itemprop="keywords" href="/posts/tags/devops/">devops</a>.
            </p>
            <p>
              Find more content by <a title="Browse writing by tags" href="/tags/">browsing by tags</a>.
            </p>
          </footer>
        </article>
        <p class='pagination'>
          <span></span>
          <span>Page 1</span>
          <span><a rel="next" href="/page/2/">Next →</a></span>
        </p>
      </div>
    </div>
    <footer class='site-footer'>
      <div class='bucket'>
        <p>Logo by <a href="http://stephanielucido.com/" title="Stephanie Lucido">Stephanie Lucido</a>.</p>
        <small>
          &copy; 2015 Jimmy Cuadra. All rights reserved.
        </small>
      </div>
    </footer>
    <script src="/javascripts/application-f844c8db.js"></script>
    <script>
    (function() {
      var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
      po.src = 'https://apis.google.com/js/platform.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
    })();
    (function(d, t) {
      var e = d.createElement(t), s = d.getElementsByTagName(t)[0];
      e.type = 'text/javascript'; e.async = true; e.src = '//platform.twitter.com/widgets.js';
      s.parentNode.insertBefore(e, s);
    })(document, 'script');
    </script>
  </body>
</html>
